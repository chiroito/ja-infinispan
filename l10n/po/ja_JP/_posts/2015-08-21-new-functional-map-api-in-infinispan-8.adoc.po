# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:1
#, fuzzy, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:10
#, fuzzy, no-wrap
msgid ""
"layout: blog\n"
"title: New Functional Map API in Infinispan 8 - Introduction\n"
"permalink: /blog/:year/:month/:day/new-functional-map-api-in-infinispan-8\n"
"date: '2015-08-21T03:08:00.000-07:00'\n"
"author: galder\n"
"tags: [ \" functional\",\"introduction\", \"API\", \"lambda\" ]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-957260515663968223\n"
"blogger_orig_url: https://blog.infinispan.org/2015/08/new-functional-map-api-in-infinispan-8.html\n"
"---\n"
msgstr ""
"layout: blog\n"
"title: Infinispan 8 の新しい機能マップ API - 概要\n"
"permalink: /blog/:year/:month/:day/new-functional-map-api-in-infinispan-8\n"
"date: '2015-08-21T03:08:00.000-07:00'\n"
"author: galder\n"
"tags: [ \" functional\",\"introduction\", \"API\", \"lambda\" ]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-957260515663968223\n"
"blogger_orig_url: https://blog.infinispan.org/2015/08/new-functional-map-api-in-infinispan-8.html\n"
"---\n"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:15
#, fuzzy
msgid "In Infinispan 8.0.0.Beta3, we have a introduced a new experimental API for interacting with your data which takes advantage of the functional programming additions and improved asynchronous programming capabilities available in Java 8."
msgstr "Infinispan 8.0.0.0.Beta3では、Java 8で利用可能な機能的なプログラミング機能の追加と改良された非同期プログラミング機能を利用して、データと対話するための新しい実験的なAPIを導入しました。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:19
#, fuzzy
msgid "Over the next few weeks we'll be introducing different aspects of the API. In this first blog post, we'll focus on why we felt there's a need for a new approach, answering a few key questions."
msgstr "今後数週間にわたって、APIのさまざまな側面を紹介していきます。この最初のブログ記事では、新しいアプローチの必要性を感じた理由に焦点を当て、いくつかの重要な質問に答えていきます。"

#. type: Title ===
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:21
#, fuzzy, no-wrap
msgid "ConcurrentMap and JCache"
msgstr "ConcurrentMapとJCache"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:38
#, fuzzy
msgid "Map­-like key/value pair APIs have often been used for distributed caching and in-­memory data grids. Initially, https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html[ConcurrentMap] became popular but this was designed to be run within a single JVM, and hence some of the operations suffered in distributed environments or when persistence stores were attached. For example, methods such as 'https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-[_V put(K, V)_]', 'https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#putIfAbsent-K-V-[_V putIfAbsent(K, V)_]', _'https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#replace-K-V-[V replace(K, V)]_' would force implementations to return the previous value, but often this value is not needed yet this could be expensive to transfer."
msgstr "マップライクなキー/値のペアAPIは、分散キャッシュやインメモリデータグリッドによく使われてきました。当初は link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html[ConcurrentMap] が普及しましたが、これは単一の JVM 内で実行するように設計されていたため、分散環境やパーシステンスストアがアタッチされている場合には、いくつかの操作に悩まされることになりました。例えば、 link:https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-[_'V put(K, V_] link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#putIfAbsent-K-V-[_)'、'V putIfAbsent(K, V_] _)'、'V replace(K, V)'_ のようなメソッドは、実装を強制的に前の値を返すようにしていますが、多くの場合、この値は必要ではありませんが、転送にはコストがかかります。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:53
#, fuzzy
msgid "https://jcp.org/en/jsr/detail?id=107[JSR­-107] set out to improve on this and came up with the https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java[JCache] specification which solved this particular problem separating operations such ConcurrentMap's 'https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-[_V put(K, V)_]' into two operations: 'https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L194[_void put(K, V)_]' and '_https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L224[V getAndPut(K, V)]'_, and it applied the same logic to other operations such as '_replace_' by providing an alternative '_https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L459[getAndReplace(K, V)]'_... etc."
msgstr "link:https://jcp.org/en/jsr/detail?id=107[JSR-107] では、これを改善するために link:https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java[JCache] 仕様を策定し、ConcurrentMapの link:https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-[_'V put(K, V)'_] のような操作を2つの操作に分離することで、この問題を解決しています。また、 link:https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L194[_'_] _replace_ 'のような他の演算にも同じロジックを適用し、' _getAndReplace(K, V)'_ に代わるものを提供しています......など。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:64
#, fuzzy
msgid "However, even though JCache was designed with distributed caching in mind, it still failed to provide an API to execute operations asynchronously and hence avoid resource under­utilization by having threads waiting for remote operations to complete.  '_https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L169[l​oadAll]'_ ​is probably the only exception, and it would have been the perfect candidate to return a http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html[F​uture​] or similar construct, but having to pass in a completion listener feels a bit clunky and cannot be chained easily."
msgstr "しかし、JCacheは分散キャッシュを念頭に置いて設計されていたにもかかわらず、操作を非同期に実行するAPIを提供することができず、リモート操作が完了するまでスレッドを待たせることによるリソースの過小利用を避けることができませんでした。 _loadAll_ ' はおそらく唯一の例外であり、 link:http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html[Future や] 類似のコンストラクタを返すのに最適な候補でしたが、完了リスナーを渡す必要があるのは少し不便に感じますし、簡単には連結できません。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:79
#, fuzzy
msgid "In my opinion, the best parts of JCache are '__https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L559[i​nvoke]'__​ and 'https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L599[_i​nvokeAll_]' methods. When you look at them, you see a lot of potential to reimplement _get_, _put_, _getAndPut_, _getAndReplace_, _putAll_,​ _getAll_, ​and many others using these methods. In other words, as an implementer, all you should need to implement is those two functions, and the rest would be syntactic sugar for the user. Unfortunately, the way '_i​nvoke_' and '_i​nvokeAll_' handle arguments is a bit clunky, and really,  it's just screaming for lambdas to be passed in and https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[C​ompletableFuture] instances to be returned (Java 8!)."
msgstr "私の考えでは、JCache の最も良い部分は _'invoke_ ' と link:https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L599[_'invokeAll_] ' メソッドです。これらを見てみると、これらのメソッドを使って _get_ _, put_ , _getAndPut_ _, getAndReplace_ _, putAll_ _, getAll_ , その他多くの関数を再実装できる可能性があることがわかります。言い換えれば、実装者として必要なのはこれら2つの関数を実装することだけで、残りはユーザのための構文的な糖質になるということです。残念ながら、 _'invoke_ ' と _'invokeAll_ ' が引数を処理する方法は少し不器用で、ランブダを渡して link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] インスタンスを返すように叫んでいるだけです (Java 8!)。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:83
#, fuzzy
msgid "So, when Infinispan moved to Java 8, we decided to revisit these concepts and see if we could come up with a better, distilled map­-like interface to be used for as either a caching or data grid API."
msgstr "そこで、InfinispanがJava 8に移行したときに、これらの概念を再検討し、キャッシングやデータグリッドAPIとして使用できるように、より良い、蒸留されたマップのようなインターフェイスを開発できないかどうかを確認することにしました。"

#. type: Title ===
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:85
#, fuzzy, no-wrap
msgid "New Functional Map API"
msgstr "新しい機能マップAPI"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:92
#, fuzzy
msgid "Infinispan's https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java[Functional Map API] is a distilled map­like asynchronous API which uses lambdas to interact with data."
msgstr "Infinispanの link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java[Functional Map APIは] 、ラムダを使ってデータと対話する蒸留されたマップライクな非同期APIです。"

#. type: Title =====
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:93
#, fuzzy, no-wrap
msgid "Asynchronous and Lazy"
msgstr "非同期と遅延"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:108
#, fuzzy
msgid "Being an asynchronous API, all methods that return a single result, return a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] which wraps the result, so you can use the resources of your system more efficiently by having the possibility to receive callbacks when the CompletableFuture has completed, or you can chain or compose them with other CompletableFuture. If you do want to block the thread and wait for the result, just as it happens with a ConcurrentMap or JCache method call, you can simply call `https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#get--[_CompletableFuture.get()_]` (for such situations, we are working on finding ways to avoid unnecessary thread creation when the caller will block on the CompletableFuture)."
msgstr "非同期 API であるため、単一の結果を返すすべてのメソッドは、結果をラップする link:https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture] を返すので、CompletableFuture が完了したときにコールバックを受け取る可能性があることで、システムのリソースをより効率的に使用することができます。ConcurrentMap や JCache メソッドの呼び出しと同じように、スレッドをブロックして結果を待ちたい場合は、単に ` _CompletableFuture.get()_ ` (そのような状況のために、呼び出し元がCompletableFutureでブロックするときに不必要なスレッドを生成しないようにする方法を見つけようとしています)。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:119
#, fuzzy
msgid "For those operations that return multiple results, the API returns instances of a ​https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/Traversable.java[Traversable] interface which offers a lazy pull­-style API for working with multiple results. Although push­-style interfaces for handling multiple results, such as RxJava, are fully asynchronous, they're harder to use from a user’s perspective. T​raversable,​ being a lazy pull­-style API, can still be asynchronous underneath since the user can decide to work on the traversable at a later stage, and the Traversable implementation itself can decide when to compute those results."
msgstr "複数の結果を返す操作に対して、APIは https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/Traversable.java[Traversable] インターフェースのインスタンスを返します。RxJavaのような複数の結果を扱うプッシュ型のインターフェースは完全に非同期ですが、ユーザーの視点から見ると使いにくいです。Traversableは遅延プルスタイルのAPIですが、ユーザーが後の段階でトラバサブルに取り組むことを決めることができ、Traversableの実装自体が結果をいつ計算するかを決めることができるので、その下ではまだ非同期であることができます。"

#. type: Title =====
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:120
#, fuzzy, no-wrap
msgid "Lambda transparency"
msgstr "ラムダ透明度"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:131
#, fuzzy
msgid "Since the content of the lambdas is transparent to Infinispan, the API has been split into 3 interfaces for read­-only (https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L106[R​eadOnlyMap])​, read­-write (https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L456[R​eadWriteMap])​ and write­-only (https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L227[W​riteOnlyMap])​ operations respectively, in order to provide hints to the Infinispan internals on the type of work needed to support lambdas."
msgstr "ラムダの内容は Infinispan からは透過的なので、ラムダをサポートするために必要な作業のヒントを Infinispan 内部に提供するために、API はそれぞれ、読み取り専用 link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L106[(ReadOnlyMap] )、読み取り専用 link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L106[(] link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L456[ReadWriteMap] )、書き込み専用 link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L227[(] WriteOnlyMap) の 3 つのインターフェイスに分割されました。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:146
#, fuzzy
msgid "For example, Infinispan has been designed in such way that our '_C​oncurrentMap.​g​et(​)_' and '_JCache.​g​etAll(​)_' implementations do not require locks to be acquired. These _get()_/_getAll()_ operations are read-only operations, and hence if you call our functional map R​eadOnlyMap's '_https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L144[eval(​)]_' or '_https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L176[e​valMany(​)]_' operations, you get the same benefit. A key advantage of R​eadOnlyMap's '_eval​()_' and '_e​valMany(​)_' operations is that they take lambdas as parameters which means the returned types are more flexible, so we can return a value associated with the key, or we can return a boolean if a value has the expected contents, or we can return some metadata parameters from it, e.g. last accessed time, last modified time, creation time, lifespan, version information...etc."
msgstr "例えば、Infinispan は _'ConcurrentMap.get(_ )' と _'JCache.getAll(_ )' の実装がロックを取得する必要がないように設計されています。これらの _get()/_ _getAll()_ 操作は読み取り専用の操作なので、機能マップ ReadOnlyMap の 'eval _()' や '_ _evalMany()'_ 操作を呼び出しても、同じ利点を得ることができます。ReadOnlyMap の _'eval()'_ や _'_ evalMany()' 操作の主な利点は、ラムダをパラメータとして受け取ることができるということです。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:166
#, fuzzy
msgid "Another important hint that is required to make efficient use of the system is to know when a write-only operation is being executed.  Write­-only operations require locks to be acquired and as demonstrated by JCache's 'https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L505[_void removeAll()_]' and `__https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L194[void put(K, V)]__' or ConcurrentMap's 'https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#putAll-java.util.Map-[_putAll()_]', they do not require the previous value to be queried or read, which as explained above is a very important optimization since reading the previous value might require the persistence layer or a remote node to be queried. WriteOnlyMap's 'https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L281[_eval()_]', 'https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L351[_evalMany()_]', and 'https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L414[_evalAll()_]' follow this same pattern with the added flexibility for the lambda to decide what kind of write operation to execute."
msgstr "システムを効率的に利用するために必要なもう一つの重要なヒントは、書き込み専用の操作がいつ実行されているかを知ることです。書き込み専用操作はロックを取得する必要がありますが、JCacheの link:https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L505[_'void removeAll()'_] や' _void put(K, V)'_ やConcurrentMapの link:https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#putAll-java.util.Map-[_'putAll()'_] で実証されているように、前の値の問い合わせや読み込みを必要としません。WriteOnlyMapの link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L281[_'eval()'、_] link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L351[_'evalMany()'、_] link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L414[_'evalAll()'_] はこの同じパターンに従っていますが、ラムダがどのような書き込み操作を実行するかを決めるための柔軟性が追加されています。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:191
#, fuzzy
msgid "The final type of operations we have are read­-write operations, and within this category we find CAS-like (Compare­-And­-Swap) operations.  This type of operations require previous value associated with the key to be read and for locks to be acquired before executing the lambda.  ￼Most of the operations in ConcurrentMap and JCache operations fall within this domain including: '_https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-[V put(K, V)]_', 'https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L283[_boolean putIfAbsent(K, V)_]', '_https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#replace-K-V-[V replace(K, V)]_', '_https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#replace-K-V-V-[boolean replace(K, V, V)]_'...etc. ReadWriteMap's '_https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L554[eval()]_', '_https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L581[evalMany()]_' and '_https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/api/functional/FunctionalMap.java#L626[evalAll()]_' provide a way to implement the vast majority of these operations thanks to the flexibility of the lambdas passed in. So you can make CAS­-like comparisons not only based on value equality but based on metadata parameter equality such as version information, and you can send back previous value or boolean instances to signal whether the CAS­-like comparison succeeded."
msgstr "最後のタイプの操作は読み書き操作で、このカテゴリにはCASライクな操作があります。このタイプの操作では、キーに関連付けられた前の値を読み込んだり、ラムダを実行する前にロックを取得したりする必要があります。 _'V put(K, V)'、'_ link:https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L283[_boolean putIfAbsent(K, V_] _)'、'V replace(K, V)_ '、 _'boolean replace(K, V, V)'_ など。ReadWriteMapの _'eval()'、_ _'evalMany()'、_ _'evalAll()'_ は、渡されたラムダの柔軟性のおかげで、これらの操作の大部分を実装する方法を提供します。つまり、値の平等性だけでなく、バージョン情報のようなメタデータパラメータの平等性に基づいて CAS ライクな比較を行うことができ、CAS ライクな比較が成功したかどうかをシグナルするために、前の値やブール値のインスタンスを送り返すことができます。"

#. type: Title ===
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:193
#, fuzzy, no-wrap
msgid "$DEITY, I need to learn a new API!!!"
msgstr "$DEITY、新しいAPIを覚える必要がある!"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:200
#, fuzzy
msgid "This new functional Map­-like API is meant to complement existing Key/Value Infinispan API offerings, so you'll still be able to use ConcurrentMap or JCache standard APIs if that's what suits your use case best."
msgstr "この新しい機能的なMapのようなAPIは、既存のKey/Value Infinispan APIの提供を補完するためのものです。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:202
#, fuzzy
msgid "The target audience for this new API is either:"
msgstr "この新しいAPIの対象者は、次のいずれかです。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:209
#, fuzzy
msgid "Distributed or persistent caching/in­-memory­ data­-grid users that want to benefit from CompletableFuture and/or Traversable for async/lazy data grid or caching data manipulation. The clear advantage here is that threads do not need to be idle waiting for remote operations to complete, but instead these can be notified when remote operations complete and then chain them with other subsequent operations."
msgstr "非同期/レイジーデータグリッドやキャッシングデータ操作のために CompletableFuture および/または Traversable の恩恵を受けたいと考えている分散型または永続的なキャッシング/インメモリデータグリッドのユーザー。ここでの明確な利点は、リモート操作が完了するまでスレッドをアイドル状態で待つ必要がなく、その代わりにリモート操作が完了したときにスレッドを通知し、他の後続の操作と一緒に連鎖させることができることです。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:213
#, fuzzy
msgid "Users wanting to go beyond the standard operations exposed by ConcurrentMap and JCache, for example, if you want to do a replace operation using metadata parameter equality instead of value equality, or if you want to retrieve metadata information from values...etc."
msgstr "例えば、値の等値性の代わりにメタデータのパラメータの等値性を使用して置換操作を行いたい場合や、値からメタデータ情報を取得したい場合など、ConcurrentMapやJCacheで公開されている標準的な操作を超えた操作を行いたいと考えているユーザーがいます。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:227
#, fuzzy
msgid "Internally, we feel that this new functional Map­-like API distills the Map­-like APIs that we currently offer (including ConcurrentMap and JCache) and gets rid of a lot of duplication in our https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/AdvancedCache.html[AdvancedCache] API (e.g.  'https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/AdvancedCache.html#getCacheEntry-java.lang.Object-[_getCacheEntry()_]', 'https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/commons/api/AsyncCache.html#getAsync-K-[_getAsync()_]', 'https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/commons/api/AsyncCache.html#putAsync-K-V-[_putAsync()_]', '_https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/AdvancedCache.html#put-K-V-org.infinispan.metadata.Metadata-[put(K, V, Metadata)]_'...etc), and hence down the line, we'd want all these APIs to be implemented using the new functional Map­like API. By doing that, we hope to reduce the number of commands that our internal architecture implements, hence reducing our code base."
msgstr "内部的には、この新しい機能的な Map ライク API は現在提供している Map ライク API (ConcurrentMap と JCache を含む) を蒸留し、 link:https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/AdvancedCache.html[AdvancedCache] API の多くの重複を取り除きます (例 link:https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/AdvancedCache.html#getCacheEntry-java.lang.Object-[_: 'getCacheEntry()'、'_] link:https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/commons/api/AsyncCache.html#getAsync-K-[_getAsync()'、_] link:https://docs.jboss.org/infinispan/8.0/apidocs/org/infinispan/commons/api/AsyncCache.html#putAsync-K-V-[_'putAsync()'、'put_] _(K, V, Metadata)' ..._ など)。そうすることで、内部アーキテクチャが実装するコマンドの数を減らし、コードベースを減らしたいと考えています。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:232
#, fuzzy
msgid "This new API also offers a new approach for passing per-invocation parameters, and much more flexible Metadata handling compared to our current approach. As we dig into this new API in next blog posts, we'll explain the differences and advantages provided by these."
msgstr "この新しい API はまた、呼び出しごとのパラメータを渡すための新しいアプローチを提供し、現在のアプローチに比べてはるかに柔軟なメタデータの処理を提供します。次回のブログ記事でこの新しい API を掘り下げていく中で、これらの違いや利点について説明していきます。"

#. type: Title ===
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:234
#, fuzzy, no-wrap
msgid "Functional Map API usage examples"
msgstr "機能マップAPIの使用例"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:242
#, fuzzy
msgid "To give you a little taste of what the API looks like, here is a write-­only operation to associate a key with a value, whose CompletableFuture has been chained so that when it completes, a read­-only operation can be executed to read the stored value, and when that completes, print it to the system output:"
msgstr "API がどのようなものかを少しだけ知るために、ここではキーと値を関連付けるための書き込み専用の操作を行います。CompletableFuture がチェーン化されており、それが完了すると、格納されている値を読み込むための読み取り専用の操作が実行され、それが完了するとシステムの出力に出力されます。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:249
#, fuzzy
msgid "You can find more examples of this new API in https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalConcurrentMap.java[FunctionalConcurrentMap] and https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalJCache.java[FunctionalJCache] classes, which are implementations of ConcurrentMap and JCache respectively using the new Functional Map API."
msgstr "この新しいAPIの例は、新しいFunctional Map APIを使用してConcurrentMapとJCacheをそれぞれ実装した link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalConcurrentMap.java[FunctionalConcurrentMapと] link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalJCache.java[FunctionalJCacheクラス] にあります。"

#. type: Title ===
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:251
#, fuzzy, no-wrap
msgid "Tell me more!!￼"
msgstr "もっと教えてください！！ 避難所So_FFFC ASB ASB"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:264
#, fuzzy
msgid "Over the next few weeks I'll be posting examples looking at the finer details of these new Functional Map APIs, but if you're eager to get started, check the classes in org.infinispan.functional package, https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalConcurrentMap.java[FunctionalConcurrentMap] and https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalJCache.java[FunctionalJCache] which are ConcurrentMap and JCache implementations based on these Functional Map APIs, and https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/FunctionalMapTest.java[FunctionalMapTest] which demonstrates operations that go beyond what ConcurrentMap and JCache offer."
msgstr "今後数週間の間に、これらの新しいFunctional Map APIの詳細についての例を掲載していきますが、もし始めたいと思っているのであれば、org.infinispan.functional packageのクラス、 link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalConcurrentMap.java[FunctionalConcurrentMapと] link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalJCache.java[FunctionalJCacheは、] これらのFunctional Map APIに基づいてConcurrentMapとJCacheを実装したもの link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/decorators/FunctionalJCache.java[で、] link:https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/functional/FunctionalMapTest.java[FunctionalMapTest] はConcurrentMapとJCacheの機能を超えた操作を実演しています。"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:266
#, fuzzy
msgid "Happy (functional) hacking :)"
msgstr "ハッピー（機能的）ハッキング :)"

#. type: Plain text
#: upstream/_posts/2015-08-21-new-functional-map-api-in-infinispan-8.adoc:267
#, fuzzy
msgid "Galder"
msgstr "ガルダー"
