# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:10
#, no-wrap
msgid ""
"layout: blog\n"
"title: The Grouping API\n"
"permalink: /blog/:year/:month/:day/grouping-api\n"
"date: '2011-06-20T04:37:00.000-07:00'\n"
"author: pmuir\n"
"tags: [api, grouping]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-2679079201051645017\n"
"blogger_orig_url: https://blog.infinispan.org/2011/06/grouping-api.html\n"
"---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:14
msgid "Infinispan 5 CR4 (and above) includes a new Grouping API. You can http://community.jboss.org/wiki/TheGroupingAPI[read more in the documentation], but I'll introduce it quickly for you here."
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:17
msgid "In some cases you may wish to co-locate a group of entries onto a particular node. In this case, the group API will be useful for you."
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:19
#, no-wrap
msgid "*How does it work?*\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:30
msgid "Infinispan allocates each node a portion of the total hash space.  Normally, when you store an entry, Infinispan will take a hash of the key, and store the entry on the node which owns that portion of the hash space. Infinispan always uses an algorithm to locate a key in the hash space, never allowing the node on which the entry is stored to be specified manually. This scheme allows any node to know which nodes owns a key, without having to distribute such ownership information. This reduces the overhead of Infinispan, but more importantly improves redundancy as there is no need to replicate the ownership information in case of node failure."
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:39
msgid "If you use the grouping API , then Infinispan will ignore the hash of the key when deciding which node to store the entry on, and instead use a hash of the group. Infinispan still uses the hash of the key to store the entry on a node. When the group API is in use, it is important that every node can still compute, using an algorithm, the owner of every key. For this reason, the group cannot be specified manually. The group can either be intrinsic to the entry (generated by the key class) or extrinsic (generated by an external function)."
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:41
#, no-wrap
msgid "*How can I use it?*\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:45
msgid "If you can alter the key class, and the determination of the group is not an orthogonal concern to the key class, then you can simply annotate a method on the key class that will provide the group. For example"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:51
#, no-wrap
msgid "class User {\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:55
#, no-wrap
msgid ""
"   ...\n"
"   String office;\n"
"   ...\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:60
#, no-wrap
msgid ""
"   int hashCode() {\n"
"      // Defines the hash for the key, normally used to determine location\n"
"      ...\n"
"   }\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:67
#, no-wrap
msgid ""
"   // Override the location by specifying a group, all keys in the same \n"
"   // group end up with the same owner\n"
"   @Group\n"
"   String getOffice() {\n"
"      return office;\n"
"   }\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:69
#: upstream/_posts/2011-06-20-grouping-api.adoc:106
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:77
msgid "Of course, you need to make sure your algorithm for computing the key is consistent, and always returns the same group for a key!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:82
msgid "Alternatively, if you can't modify the key class, or determination of the group is an orthogonal concern, you can externalise computation of the group to an \"interceptor style\" class, called a \"Grouper\". Let's take a look an example of a Grouper:"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:88
#, no-wrap
msgid "class KXGrouper implements Grouper {\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:91
#, no-wrap
msgid ""
"    // A pattern that can extract from a \"kX\" (e.g. k1, k2) style key\n"
"   static Pattern kPattern = Pattern.compile(\"(^k)(\\\\d)$\");\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:100
#, no-wrap
msgid ""
"    String computeGroup(String key, String group) {\n"
"        Matcher matcher = kPattern.matcher(key);\n"
"        if (matcher.matches()) {\n"
"            String g = Integer.parseInt(matcher.group(2)) % 2 + \"\";\n"
"            return g;\n"
"        } else\n"
"            return null;\n"
"    }\n"
msgstr ""

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:104
#, no-wrap
msgid ""
"    Class getKeyType() {\n"
"        return String.class;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:114
msgid "Here, we've had to use a grouper, as we cannot modify the key class (`String`). Our group is still based upon the key, and established by extracting a part of the key."
msgstr ""

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:118
msgid "Of course, you need to enable grouping support in Infinispan, and configure any groupers. The http://community.jboss.org/wiki/TheGroupingAPI[reference documentation] will help you here."
msgstr ""
