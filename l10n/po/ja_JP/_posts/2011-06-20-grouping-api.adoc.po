# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:1
#, fuzzy, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:10
#, fuzzy, no-wrap
msgid ""
"layout: blog\n"
"title: The Grouping API\n"
"permalink: /blog/:year/:month/:day/grouping-api\n"
"date: '2011-06-20T04:37:00.000-07:00'\n"
"author: pmuir\n"
"tags: [api, grouping]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-2679079201051645017\n"
"blogger_orig_url: https://blog.infinispan.org/2011/06/grouping-api.html\n"
"---\n"
msgstr ""
"layout: blog\n"
"title: グループ化API\n"
"permalink: /blog/:year/:month/:day/grouping-api\n"
"date: '2011-06-20T04:37:00.000-07:00'\n"
"author: pmuir\n"
"tags: [api, grouping]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-2679079201051645017\n"
"blogger_orig_url: https://blog.infinispan.org/2011/06/grouping-api.html\n"
"---\n"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:14
#, fuzzy
msgid "Infinispan 5 CR4 (and above) includes a new Grouping API. You can http://community.jboss.org/wiki/TheGroupingAPI[read more in the documentation], but I'll introduce it quickly for you here."
msgstr "Infinispan 5 CR4（およびそれ以上）には、新しいGrouping APIが含まれています。詳細 link:http://community.jboss.org/wiki/TheGroupingAPI[はドキュメントを読んで] いただければわかると思いますが、ここでは手っ取り早く紹介しておきます。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:17
#, fuzzy
msgid "In some cases you may wish to co-locate a group of entries onto a particular node. In this case, the group API will be useful for you."
msgstr "エントリのグループを特定のノードに配置したい場合もあるでしょう。このような場合には、group APIが便利です。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:19
#, fuzzy, no-wrap
msgid "*How does it work?*\n"
msgstr "*どうやって使うのか？*"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:30
#, fuzzy
msgid "Infinispan allocates each node a portion of the total hash space.  Normally, when you store an entry, Infinispan will take a hash of the key, and store the entry on the node which owns that portion of the hash space. Infinispan always uses an algorithm to locate a key in the hash space, never allowing the node on which the entry is stored to be specified manually. This scheme allows any node to know which nodes owns a key, without having to distribute such ownership information. This reduces the overhead of Infinispan, but more importantly improves redundancy as there is no need to replicate the ownership information in case of node failure."
msgstr "Infinispanは各ノードに総ハッシュ空間の一部を割り当てます。通常、エントリを格納するとき、Infinispanはキーのハッシュを取り、ハッシュ空間のその部分を所有しているノードにエントリを格納します。Infinispanは常にアルゴリズムを使用してハッシュ空間内のキーを見つけ、エントリが格納されているノードを手動で指定することはありません。この方式により、どのノードがキーを所有しているかを知ることができ、そのような所有情報を配布する必要がありません。これにより、Infinispanのオーバーヘッドが削減されますが、より重要なことは、ノードに障害が発生した場合に所有情報を複製する必要がないため、冗長性が向上します。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:39
#, fuzzy
msgid "If you use the grouping API , then Infinispan will ignore the hash of the key when deciding which node to store the entry on, and instead use a hash of the group. Infinispan still uses the hash of the key to store the entry on a node. When the group API is in use, it is important that every node can still compute, using an algorithm, the owner of every key. For this reason, the group cannot be specified manually. The group can either be intrinsic to the entry (generated by the key class) or extrinsic (generated by an external function)."
msgstr "グループ化APIを使用している場合、Infinispanはエントリを格納するノードを決定する際にキーのハッシュを無視し、代わりにグループのハッシュを使用します。Infinispan は、ノードにエントリを格納する際にもキーのハッシュを使用します。グループAPIが使用されている場合、すべてのノードがアルゴリズムを使用して、すべてのキーの所有者を計算できることが重要です。このため、グループを手動で指定することはできません。グループは、エントリに固有のもの（キークラスによって生成される）か、外部関数によって生成されるもの（外部関数によって生成される）のどちらかになります。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:41
#, fuzzy, no-wrap
msgid "*How can I use it?*\n"
msgstr "*どのように使えばいいのでしょうか？*"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:45
#, fuzzy
msgid "If you can alter the key class, and the determination of the group is not an orthogonal concern to the key class, then you can simply annotate a method on the key class that will provide the group. For example"
msgstr "キークラスを変更することができ、グループの決定がキークラスと直交しない場合は、グループを提供するメソッドをキークラスにアノテーションすればよいのです。例えば、以下のようになります。"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:51
#, fuzzy, no-wrap
msgid "class User {\n"
msgstr "class User {"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:55
#, fuzzy, no-wrap
msgid ""
"   ...\n"
"   String office;\n"
"   ...\n"
msgstr ""
"...\n"
"文字列事務所。\n"
"..."

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:60
#, fuzzy, no-wrap
msgid ""
"   int hashCode() {\n"
"      // Defines the hash for the key, normally used to determine location\n"
"      ...\n"
"   }\n"
msgstr ""
"int hashCode() {\n"
"   // キーのハッシュを定義します。\n"
"   ...\n"
"}"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:67
#, fuzzy, no-wrap
msgid ""
"   // Override the location by specifying a group, all keys in the same \n"
"   // group end up with the same owner\n"
"   @Group\n"
"   String getOffice() {\n"
"      return office;\n"
"   }\n"
msgstr ""
"// グループを指定して場所を上書きします。\n"
"//グループは、同じ所有者で終わる\n"
"グループ\n"
"String getOffice() {.\n"
"   ≪(渡真利)はい ≪(渡真利)帰ってきました\n"
"}"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:69
#: upstream/_posts/2011-06-20-grouping-api.adoc:106
#, fuzzy, no-wrap
msgid "}\n"
msgstr "}"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:77
#, fuzzy
msgid "Of course, you need to make sure your algorithm for computing the key is consistent, and always returns the same group for a key!"
msgstr "もちろん、キーを計算するアルゴリズムが一貫していて、キーに対して常に同じグループを返すことを確認する必要があります。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:82
#, fuzzy
msgid "Alternatively, if you can't modify the key class, or determination of the group is an orthogonal concern, you can externalise computation of the group to an \"interceptor style\" class, called a \"Grouper\". Let's take a look an example of a Grouper:"
msgstr "あるいは、キークラスを変更できない場合や、グループの決定が直交的な関心事である場合は、グループの計算を\"Grouper\"と呼ばれる\"インターセプタースタイル\"のクラスに外付けすることができます。グルーパーの例を見てみましょう。"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:88
#, fuzzy, no-wrap
msgid "class KXGrouper implements Grouper {\n"
msgstr "class KXGrouper implements Grouper {"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:91
#, fuzzy, no-wrap
msgid ""
"    // A pattern that can extract from a \"kX\" (e.g. k1, k2) style key\n"
"   static Pattern kPattern = Pattern.compile(\"(^k)(\\\\d)$\");\n"
msgstr ""
"// \"kX\" (例: k1, k2) スタイルキーから抽出できるパターン\n"
"static Pattern kPattern = Pattern.compile(\"(^k)(\\d)$\")."

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:100
#, fuzzy, no-wrap
msgid ""
"    String computeGroup(String key, String group) {\n"
"        Matcher matcher = kPattern.matcher(key);\n"
"        if (matcher.matches()) {\n"
"            String g = Integer.parseInt(matcher.group(2)) % 2 + \"\";\n"
"            return g;\n"
"        } else\n"
"            return null;\n"
"    }\n"
msgstr ""
"String computeGroup(String key, String group) { String computeGroup(String key, String group)\n"
"    Matcher matcher = kPattern.matcher(key)。\n"
"    if (matcher.matches()) {\n"
"        文字列 g = Integer.parseInt(matcher.group(2)) % 2 + \"\".\n"
"        g を返します。\n"
"    他には\n"
"        nullを返します。\n"
"}"

#. type: delimited block .
#: upstream/_posts/2011-06-20-grouping-api.adoc:104
#, fuzzy, no-wrap
msgid ""
"    Class getKeyType() {\n"
"        return String.class;\n"
"    }\n"
msgstr ""
"クラス getKeyType() {\n"
"    String.classを返します。\n"
"}"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:114
#, fuzzy
msgid "Here, we've had to use a grouper, as we cannot modify the key class (`String`). Our group is still based upon the key, and established by extracting a part of the key."
msgstr "ここでは、キークラス ( `String` ) を変更することができないので、グルーパを使用しなければなりませんでした。私たちのグループはまだキーに基づいており、キーの一部を抽出することで確立されています。"

#. type: Plain text
#: upstream/_posts/2011-06-20-grouping-api.adoc:118
#, fuzzy
msgid "Of course, you need to enable grouping support in Infinispan, and configure any groupers. The http://community.jboss.org/wiki/TheGroupingAPI[reference documentation] will help you here."
msgstr "もちろん、Infinispan でグループ化サポートを有効にして、グルーパを設定する必要があります。ここでは、 link:http://community.jboss.org/wiki/TheGroupingAPI[リファレンスドキュメント] を参照してください。"
