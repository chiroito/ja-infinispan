# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:1
#, fuzzy, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:13
#, fuzzy, no-wrap
msgid ""
"layout: blog\n"
"title: Fine-grained replication in Infinispan\n"
"permalink: /blog/:year/:month/:day/fine-grained-replication-in-infinispan\n"
"date: '2012-06-21T07:21:00.001-07:00'\n"
"author: mgencur\n"
"tags: [ \"replication\",\n"
"\"fine grained\",\n"
"\"state transfer\",\n"
"]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-5017518189290873036\n"
"blogger_orig_url: https://blog.infinispan.org/2012/06/fine-grained-replication-in-infinispan.html\n"
"---\n"
msgstr ""
"layout: blog\n"
"title: Infinispanでのきめ細かなレプリケーション\n"
"permalink: /blog/:year/:month/:day/fine-grained-replication-in-infinispan\n"
"date: '2012-06-21T07:21:00.001-07:00'\n"
"author: mgencur\n"
"tags: [ \"replication\",\n"
"\"fine grained\",\n"
"\"state transfer\",\n"
"]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-5017518189290873036\n"
"blogger_orig_url: https://blog.infinispan.org/2012/06/fine-grained-replication-in-infinispan.html\n"
"---\n"

#. type: Title ==
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:14
#, fuzzy, no-wrap
msgid "[.underline]##"
msgstr "[.underline]###"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:27
#, fuzzy
msgid "Sometimes we have a large object, possibly with lots of attributes or holding some binary data, and we would like to tell Infinispan to replicate only certain part of the object across the cluster. Typically, we wanna replicate only that part which we've just updated. This is where DeltaAware and Delta interfaces come to play. By providing implementations of these interfaces we can define fine-grained replication. When we put some effort into such such an enhancements, we would also like to speed up object marshalling and unmarshalling.  Therefore, we're going to define our own externalizers - to avoid slow default Java serialization."
msgstr "大きなオブジェクトがあって、多くの属性を持っていたり、バイナリデータを保持していたりする場合がありますが、Infinispan にオブジェクトの特定の部分だけをクラスタ全体にレプリケートするように指示したい場合があります。通常、更新した部分だけをレプリケートしたい場合が多いです。ここでDeltaAwareとDeltaインターフェイスの出番です。これらのインターフェイスの実装を提供することで、より細かいレプリケーションを定義することができます。このような機能強化に力を入れると、オブジェクトのマーシャリングやアンマーシャリングも高速化したいところです。そのため、デフォルトのJavaシリアライズが遅くなるのを避けるために、独自の外部ライザを定義することにしました。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:33
#, fuzzy
msgid "The following code snippets are gathered in a complete example at https://github.com/mgencur/infinispan-examples/tree/master/partial-state-transfer This project contains a readme file with instructions on how to build and run the example. It is based on clustered-cache quickstart in Infinispan."
msgstr "以下のコードスニペットは、 https://github.com/mgencur/infinispan-examples/tree/master/partial-state-transfer にある完全な例にまとめられています。 このプロジェクトには、例を構築して実行する方法を説明する readme ファイルが含まれています。これは Infinispan の clustered-cache quickstart に基づいています。"

#. type: Title ===
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:35
#, fuzzy, no-wrap
msgid "Implementing DeltaAware interface"
msgstr "DeltaAwareインターフェースの実装"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:44
#, fuzzy
msgid "So let's look at our main object. For the purpose of this exercise, I defined a Bicycle class that consists of many components like frame, fork, rearShock, etc. This object is stored in a cache as a value under certain (not important) key. It might happen in our scenario that we update only certain components of the bike and in such case we want to replicate just those component changes."
msgstr "それでは、メインのオブジェクトを見てみましょう。この演習の目的のために、フレーム、フォーク、リアショックなどの多くのコンポーネントで構成されるBicycleクラスを定義しました。このオブジェクトは、ある（重要ではない）キーの下で値としてキャッシュに保存されます。私たちのシナリオでは、自転車の特定のコンポーネントだけを更新することが起こるかもしれませんが、そのような場合には、それらのコンポーネントの変更だけを複製したいと思います。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:46
#, fuzzy
msgid "Important methods here are (description taken from javadocs):"
msgstr "ここで重要なメソッドは以下の通りです（説明はjavadocsより引用）。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:54
#, fuzzy
msgid "commit() - Indicates that all deltas collected to date has been extracted (via a                  call to delta()) and can be discarded. Often used as an optimization if                  the delta isn't really needed, but the cleaning and resetting of                         internal state is desirable."
msgstr "commit() - これまでに収集したすべてのデルタが（delta() を呼び出すことで）抽出され、破棄できることを示します。デルタが本当に必要ではない場合に最適化のために使用されることが多いですがのクリーニングとリセットが望ましい場合に最適化として使用されます。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:70
#, fuzzy
msgid "delta() - Extracts changes made to implementations, in an efficient format that              can easily and cheaply be serialized and deserialized.  This method will              only be called once for each changeset as it is assumed that any              implementation's internal changelog is wiped and reset after generating              and submitting the delta to the caller.            We also need to define setters and getters for our members. Setter methods are, among other things, responsible for registering changes to the changelog that will be later used to reconstruct the object's state.  The externalizer for this class is only needed when cache stores are used. For the sake of simplicity, I don't mention it here."
msgstr "delta() - 実装に加えられた変更を、簡単かつ安価にシリアライズおよびデシリアライズできる効率的な形式で抽出します。このメソッドは、各チェンジセットに対して一度だけ呼び出されます。実装の内部変更ログは、デルタを生成して呼び出し元に送信した後に消去され、リセットされることを前提としているため、このメソッドは各変更セットに対して一度だけ呼び出されます。また、メンバーのセッターとゲッターも定義する必要があります。セッター・メソッドは、とりわけ、後にオブジェクトの状態を再構築するために使用されるチェンジログへの変更を登録する責任があります。このクラスのアウタライザーは、キャッシュストアが使用される場合にのみ必要となります。簡単にするために、ここでは触れません。"

#. type: Title ===
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:75
#, fuzzy, no-wrap
msgid "Implementing Delta interface"
msgstr "デルタインターフェースの実装"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:88
#, fuzzy
msgid "Actual object that will be replicated across the cluster is the implementation of Delta interface. Let's look at the class. First, we need a field that will hold the changes - changeLog. Second, we need to define a merge() method. This method must be implemented so that Infinispan knows how to merge an existing object with incoming changes.  The parameter of this method represents an object that is already stored in a cache, incoming changes will be applied to this object. We're using a reflection here to apply the changes to the actual object but it is not necessary. We could easily call setter methods. The advantage of using reflection is that we can set those fields in a loop."
msgstr "実際にクラスタをまたいでレプリケートされるオブジェクトはDeltaインターフェイスの実装です。クラスを見てみましょう。最初に、変更を保持するフィールドが必要です - changeLog。次に、merge()メソッドを定義する必要があります。このメソッドは、Infinispan が既存のオブジェクトを着信する変更をマージする方法を知っているように実装する必要があります。このメソッドのパラメータは、すでにキャッシュに保存されているオブジェクトを表し、入ってきた変更はこのオブジェクトに適用されます。ここでは、実際のオブジェクトに変更を適用するためにリフレクションを使用していますが、その必要はありません。セッターメソッドを簡単に呼び出すことができます。リフレクションを使用する利点は、ループでフィールドを設定できることです。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:92
#, fuzzy
msgid "Another piece is a registerComponentChange() method. This is called by an object of the Bicycle class - to record changes to that object. The name of this method is not important."
msgstr "もう一つは registerComponentChange() メソッドです。これは Bicycle クラスのオブジェクトによって呼び出され、そのオブジェクトへの変更を記録します。このメソッドの名前は重要ではありません。"

#. type: Title ===
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:94
#, fuzzy, no-wrap
msgid "Defining our own externalizer "
msgstr "独自の外部ライザの定義"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:102
#, fuzzy
msgid "Alright, so what remains is the externalizer definition for the Delta implementation. We implement AdvancedExternalizer interface and say that only changeLog object should be marshalled and unmarshalled when transfering data over the wire. A complete (almost) implementation of Delta interface is the following."
msgstr "さてさて、残っているのはデルタの実装のためのアウタライザー定義です。AdvancedExternalizerインターフェイスを実装して、ワイヤでデータを転送するときに、changeLogオブジェクトだけがマーシャルされていて、マーシャルされていない方がいいと言います。デルタインターフェイスの完全な(ほぼ)実装は以下の通りです。"

#. type: Title ===
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:106
#, fuzzy, no-wrap
msgid "Tell Infinispan about the extra externalizer"
msgstr "Infinispanにエクストラ・アウタライザーを教えてあげてください。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:113
#, fuzzy
msgid "We also need to configure Infinispan to use our special externalizer to marshall/unmarshall our objects. We can do it e.g. programatically by calling .addAdvancedExternalizer() on the serialization configuration builder."
msgstr "また、オブジェクトをマーシャル/アンマーシャルするために、特別な外部ライザを使用するように Infinispan を設定する必要があります。シリアライゼーション設定ビルダーで .addAdvancedExternalizer() を呼び出すことでプログラム的に行うことができます。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:118
#, fuzzy
msgid "You can see we're also configuring transactions here. This is not necessary, though. We just aim to provide a richer example, removing transactional behavior is trully easy."
msgstr "ここでもトランザクションを設定しているのがわかりますね。しかし、これは必要ありません。トランザクションの動作を削除することは本当に簡単です。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:122
#, fuzzy
msgid "And here comes the \"usage\" part. Enclose cache calls by a transaction, retrieve a bicycle object from the cache, do some changes and commit them."
msgstr "そして、ここからが「使い方」の部分です。トランザクションでキャッシュコールを囲み、キャッシュから自転車のオブジェクトを取得し、変更を加えてコミットします。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:127
#, fuzzy
msgid "That's it. What is eventually transferred over the wire is just the changeLog object. The actual bicycle object is reconstructed from incomming updates."
msgstr "それだけです。最終的にワイヤを介して転送されるのは、changeLogオブジェクトだけです。実際の自転車オブジェクトは、インコミングの更新から再構築されています。"

#. type: Plain text
#: upstream/_posts/2012-06-21-fine-grained-replication-in-infinispan.adoc:138
#, fuzzy
msgid "If all of this seem to be too complex to you, I have good news.  Infinispan provides one implementation of DeltaAware interface whish is called AtomicHashMap (package org.infinispan.atomic). If this map is used as a value in key/value pairs stored in the cache, only puts/gets/removes performed to this map during a transaction are replicated to other nodes. Classes like Bicycle and BicycleDelta are not need then. Even registering the externalizer for AtomicHashMap is not needed, this is done automatically during registration of internal externalizers. However, one might want a class emulating a real-world object, not just a map. That's the case when your own implementations of DeltaAware and Delta interfaces are the only way."
msgstr "もし、このすべてが複雑すぎると思われるならば、良いニュースがあります。InfinispanはAtomicHashMap（パッケージorg.infinispan.atomic）と呼ばれるDeltaAwareインターフェイスの1つの実装を提供しています。このマップがキャッシュに格納されたキー/値のペアの値として使用されている場合、トランザクション中にこのマップに実行されたput/gets/removeのみが他のノードにレプリケートされます。その場合、Bicycle や BicycleDelta のようなクラスは必要ない。AtomicHashMap用の外部ライザの登録も不要であり、内部外部ライザの登録時に自動的に行われる。しかし、マップだけではなく、実世界のオブジェクトをエミュレートするクラスが欲しいと思うかもしれません。これは、DeltaAwareやDeltaインターフェイスの独自の実装が唯一の方法である場合です。"
