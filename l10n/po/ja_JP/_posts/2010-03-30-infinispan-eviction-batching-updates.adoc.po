# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:1
#, no-wrap, fuzzy
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:13
#, no-wrap, fuzzy
msgid ""
"layout: blog\n"
"title: Infinispan eviction, batching updates and LIRS\n"
"permalink: /blog/:year/:month/:day/infinispan-eviction-batching-updates\n"
"date: '2010-03-30T03:50:00.000-07:00'\n"
"author: vblagojevic\n"
"tags: [ \"eviction\",\n"
"\"concurrency\",\n"
"\"data structures\",\n"
"]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-"
"9203379330709829373\n"
"blogger_orig_url: https://blog.infinispan.org/2010/03/infinispan-eviction-"
"batching-updates.html\n"
"---\n"
msgstr ""
"layout: blog\n"
"title: インフィニスパンの立ち退き、一括更新、LIRS\n"
"permalink: /blog/:year/:month/:day/infinispan-eviction-batching-updates\n"
"date: '2010-03-30T03:50:00.000-07:00'\n"
"author: vblagojevic\n"
"tags: [ \"eviction\",\n"
"\"concurrency\",\n"
"\"data structures\",\n"
"]\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-"
"9203379330709829373\n"
"blogger_orig_url: https://blog.infinispan.org/2010/03/infinispan-eviction-"
"batching-updates.html\n"
"---\n"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:23
#, fuzzy
msgid ""
"DataContainer abstraction represents the heart of Infinispan. It is a "
"container structure where actual cache data resides. Every put, remove, get "
"and other invoked cache operations eventually end up in the data container. "
"Therefore, it is of utmost importance the data container is implemented in a "
"way that does not impede overall system throughput.  Also recall that the "
"data container's memory footprint can not grow indefinitely because we would "
"eventually run out of memory; we have to periodically evict certain entries "
"from the data container according to a chosen eviction algorithm."
msgstr ""
"DataContainer の抽象化は Infinispan "
"の心臓部を表しています。これは実際のキャッシュデータが格納されるコンテナ構造です。put、remove、get、その他のキャッシュ操作が呼び出されるたびに、最終的にはデータコンテナに格納されます。したがって、データコンテナがシステム全体のスループットを阻害しないように実装されていることが最も重要です。また、データコンテナのメモリフットプリントは無期限に増加することはできないことを覚えておいてください。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:33
#, fuzzy
msgid ""
"LRU eviction algorithm, although simple and easy to understand, under "
"performs in cases of weak access locality (one time access entries are not "
"timely replaced, entries to be accessed soonest are unfortunately replaced, "
"and so on). Recently, a new eviction algorithm - http://portal.acm.org/"
"citation.cfm?id=511334.511340[LIRS] has gathered a lot of attention because "
"it addresses weak access locality shortcomings of LRU yet it retains LRU's "
"simplicity."
msgstr ""
"LRUの退避アルゴリズムはシンプルでわかりやすいが、アクセスの局所性が弱い場合（1回のアクセスエントリがタイムリーに置換されない、最も早くアクセスされるエントリが不幸にも置換されてしまうなど）には性能が劣る。最近では、LRUのシンプルさを維持しつつ、LRUの弱アクセス・ロカリティの欠点を解消した新しい退避アルゴリズムである "
"link:http://portal.acm.org/citation.cfm?id=511334.511340[LIRS] が注目を集めています。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:47
#, fuzzy
msgid ""
"However, no matter what eviction algorithm is utilized, if eviction is not "
"implemented in a scalable, low lock contention approach, it can seriously "
"degrade overall system performance. In order to do any meaningful selection "
"of entries for eviction we have to lock data container until appropriate "
"eviction entries are selected. Having such a lock protected data container "
"in turn causes high lock contention offsetting any eviction precision gained "
"by sophisticated eviction algorithms. In order to get superior throughput "
"while retaining high eviction precision we need both low lock contention "
"data container and high precision eviction algorithm implementation – a "
"seemingly impossible feat."
msgstr ""
"しかし、どのような退避アルゴリズムを利用しても、退避がスケーラブルでロック競合の少ないアプローチで実装されていなければ、システム全体のパフォーマンスを著しく低下させる可能性があります。退避エントリの意味のある選択を行うためには、適切な退避エントリが選択されるまでデータコンテナをロックしなければなりません。このようなロック保護されたデータコンテナを持つことで、高度な退避アルゴリズムによって得られる退避精度を相殺する高いロック競合が発生します。高い退避精度を維持しながら優れたスループットを得るためには、低いロック競合データコンテナと高い精度の退避アルゴリズムの実装の両方が必要です。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:75
#, fuzzy
msgid ""
"Instead of making a trade-off between the high precision eviction algorithm "
"and the low lock contention there is http://portal.acm.org/citation.cfm?id="
"1546683.1547428[a third approach]: we keep lock protected data container but "
"we amortize locking cost through batching updates. The basic idea is to wrap "
"any eviction algorithm with a framework that keeps track of cache access per "
"thread (i.e. ThreadLocal) in a simple queue. For each cache hit associated "
"with a thread, the access is recorded in the thread’s queue. If thread's "
"queue is full or the number of accesses recorded in the queue reaches a "
"certain pre-determined threshold, we acquire a lock and then execute "
"operations defined by the eviction algorithm - once for all the accesses in "
"the queue. A thread is allowed to access many cache items without requesting "
"a lock to run the eviction replacement algorithm, or without paying the lock "
"acquisition cost. We fully exploit a non-blocking lock APIs like tryLock. As "
"you recall tryLock makes an attempt to get the lock and if the lock is "
"currently held by another thread, it fails without blocking its caller "
"thread. Although tryLock is cheap it is not used for every cache access for "
"obvious reasons but rather on certain pre-determined thresholds. In case "
"when thread's queue is totally full a lock must be explicitly requested. "
"Therefore, using batching updates approach we significantly lower the cost "
"of lock contention, streamline access to locked structures and retain the "
"precision of eviction algorithm such as LIRS. The key insight is that "
"batching the updates on the eviction algorithm doesn't materially affect the "
"accuracy of the algorithm."
msgstr ""
"高精度な退避アルゴリズムと低いロック競合との間でトレードオフを行う代わりに、 link:http://portal.acm.org/citation."
"cfm?id=1546683.1547428[第三のアプローチ] があります: "
"ロックで保護されたデータコンテナを保持しますが、更新をバッチ処理することでロックコストを償却します。基本的な考え方は、任意の退避アルゴリズムを、スレッドごとのキャッシュアクセス（すなわちThreadLocal）を単純なキューで追跡するフレームワークでラップすることです。スレッドに関連付けられたキャッシュヒットごとに、そのアクセスはスレッドのキューに記録されます。スレッドのキューが一杯になった場合や、キューに記録されたアクセスの数が予め定められた閾値に達した場合、ロックを取得してから退避アルゴリズムによって定義された操作を実行します "
"- "
"キュー内のすべてのアクセスに対して一度だけ。スレッドは、退避置換アルゴリズムを実行するためにロックを要求することなく、あるいはロック取得コストを支払うことなく、多くのキャッシュアイテムにアクセスすることができます。我々は完全にtryLockのような非ブロッキングロックAPIを利用しています。ご記憶の通り、tryLockはロックの取得を試み、ロックが現在別のスレッドによって保持されている場合、呼び出し元のスレッドをブロックすることなく失敗します。tryLock "
"は安価ですが、明らかな理由からすべてのキャッシュアクセスに使用されるわけではなく、あらかじめ決められたしきい値で使用されます。スレッドのキューが完全に一杯になった場合には、明示的にロックを要求しなければなりません。したがって、更新のバッチ処理アプローチを使用することで、ロック競合のコストを大幅に下げ、ロックされた構造体へのアクセスを合理化し、LIRSのような退避アルゴリズムの精度を維持することができます。重要な洞察は、退去アルゴリズムの更新をバッチ処理することで、アルゴリズムの精度に大きな影響を与えないことである。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:90
#, fuzzy
msgid ""
"How are these ideas implemented in Infinispan? We introduced "
"BoundedConcurrentHashMap class based on Doug Lea's ConcurrentHashMap.  "
"BoundedConcurrentHashMap hashes entries based on their keys into lock "
"protected segments. Instead of recording entries accessed per thread we "
"record them in a lock free queue on a segment level. The main reason not to "
"use ThreadLocal is that we could potentially have hundreds of threads "
"hitting the data container, some of them very short lived thus possibly "
"never reaching batching thresholds. When predetermined thresholds are "
"reached eviction algorithms is executed on a segment level. Would running "
"eviction algorithm on a segment level rather than entire data container "
"impact overall eviction precision? In our performance tests we have not "
"found any evidence of that."
msgstr ""
"これらのアイデアはInfinispanではどのように実装されているのでしょうか？Doug "
"LeaのConcurrentHashMapをベースにBoundedConcurrentHashMapクラスを導入しました。BoundedConcurrentHashMap "
"は、キーに基づいたエントリをロック保護されたセグメントにハッシュします。スレッドごとにアクセスされたエントリを記録するのではなく、セグメントレベルでロックフリーのキューに記録します。ThreadLocal "
"を使用しない主な理由は、何百ものスレッドがデータコンテナにアクセスする可能性があり、そのうちのいくつかは非常に短命であるため、バッチングのしきい値に到達しない可能性があるからです。予め設定されたしきい値に達すると、イビクション・アルゴリズムはセグメント・レベルで実行されます。エビクション・アルゴリズムをデータ・コンテナ全体ではなくセグメント・レベルで実行すると、全体的なエビクション精度に影響を与えますか?当社のパフォーマンステストでは、その証拠は見つかりませんでした。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:106
#, fuzzy
msgid ""
"Infinispan's eviction algorithm is specified using strategy attribute of "
"eviction XML element. In addition to old eviction approaches, starting with "
"release 4.1.ALPHA2, you can now select LIRS eviction algorithm. LRU remains "
"the default. Also note that starting with 4.1ALPHA2 release there are two "
"distinct approaches to actually evict entries from the cache: piggyback and "
"the default approach using a dedicated EvictionManager thread. Piggyback "
"eviction thread policy, as it name implies, does eviction by piggybacking on "
"user threads that are hitting the data container. Dedicated EvictionManager "
"thread is unchanged from the previous release and it remains the default "
"option. In order to support these two eviction thread policies a new "
"eviction attribute threadPolicy has been added to eviction element of "
"Infinispan configuration schema."
msgstr ""
"Infinispanの退避アルゴリズムは、退避XML要素のstrategy属性を使用して指定します。古い退去アプローチに加えて、リリース4.1."
"ALPHA2からは、LIRS退去アルゴリズムを選択できるようになりました。LRUがデフォルトのままです。また、4."
"1ALPHA2リリースからは、実際にキャッシュからエントリを退避させるために、ピギーバックと専用のEvictionManagerスレッドを使用するデフォルトのアプローチの2つの異なるアプローチがあることにも注意してください。ピギーバック退避スレッドポリシーは、その名の通り、データコンテナをヒットしているユーザースレッドをピギーバックすることで退避を行います。専用のEvictionManagerスレッドは以前のリリースから変更されておらず、デフォルトのオプションのままです。これら2つの退避スレッド・ポリシーをサポートするために、新しい退避属性threadPolicyがInfinispan構成スキーマの退避要素に追加されました。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:119
#, fuzzy
msgid ""
"Does eviction redesign based on batching updates promise to live up to its "
"expectations? Ding et al, authors of the original batching proposal, found "
"that their framework increased throughput nearly twofold in comparison with "
"unmodified eviction in postgreSQL 8.2.3. We do not have any numbers to share "
"yet, however, initial testing of BoundedConcurrentHashMap were indeed "
"promising. One of our partner companies replaced their crucial caching "
"component with BoundedConcurrentHashMap and realized a 54% performance "
"improvement on the Berlin SPARQL benchmark for their flagship product. Stay "
"tuned for more updates."
msgstr ""
"バッチングアップデートに基づくエビクションの再設計は、その期待に応えることを約束しているのでしょうか？オリジナルのバッチ処理の提案の著者であるDingらは、彼らのフレームワークは、postgreSQL "
"8.2."
"3の修正されていないイビクションと比較して、スループットが2倍近く向上していることを発見しました。まだ数値は出ていませんが、BoundedConcurrentHashMapの初期テストでは、確かに有望な結果が出ていました。あるパートナー企業では、重要なキャッシュコンポーネントをBoundedConcurrentHashMapに置き換え、同社の主力製品であるBerlin "
"SPARQLベンチマークで54%のパフォーマンス向上を実現しました。今後のアップデートにご期待ください。"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:123
#, fuzzy
msgid "Cheers,"
msgstr "乾杯"

#. type: Plain text
#: upstream/_posts/2010-03-30-infinispan-eviction-batching-updates.adoc:124
#, fuzzy
msgid "Vladimir"
msgstr "ウラジミール"
