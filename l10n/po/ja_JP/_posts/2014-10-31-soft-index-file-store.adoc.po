# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-02-11 23:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:10
#, no-wrap
msgid ""
"layout: blog\n"
"title: Soft-Index File Store\n"
"permalink: /blog/:year/:month/:day/soft-index-file-store\n"
"date: '2014-10-31T07:14:00.000-07:00'\n"
"author: infinispan\n"
"tags: []\n"
"blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-9086839281399482868\n"
"blogger_orig_url: https://blog.infinispan.org/2014/10/soft-index-file-store.html\n"
"---\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:15
msgid "Recently, Infinispan got a new local file-based cache store, called Soft-Index File Store. Why have we created just another cache store, what problems is it solving, what are its limitations and how is it designed?"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:25
msgid "Single File Store is a well performing cache store, but it stores all keys in-memory; that limits the number of keys you can store. File fragmentation could be even more of an issue: if you store larger and larger values (that happens quite a lot, as users e.g. add stuff into their shopping carts), the space is not reused and instead the entry is appended at the end of the file. The space (now empty) is reused only if you write entry that can fit there. Also, even if you remove all entries from the cache, the file won't shrink, and neither won't be de-fragmented."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:30
msgid "LevelDB uses quite well performing Google's library written in native code. The major drawback is the native code - if LevelDB has a bug that ends in segfault, whole JVM crashes, bringing you application server down."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:40
msgid "Our new Soft Index File Store is pure Java implementation that tries to get around Single File Store's drawbacks by implementing a variant of *B+ tree* that is cached in-memory using Java's *soft references* - here's where the name Soft Index File Store comes from. This B+ tree (called Index) is offloaded on filesystem to single file: in fact, this has theoretically similar problems with fragmentation as Single File Store - but in practice it shouldn't cause such problems. This index file does not need to be persisted - it is purged and rebuilt when the cache store restarts, its purpose is only offloading."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:49
msgid "The data that should be persisted are stored in a set of files that are written in append-only way - that means that if you store this on conventional magnetic disk, it does not have to seek when writing a burst of entries. It is not stored in a single file but in a set of files. When any of these files drops below 50% of usage (the entries are marked as removed or overwritten), the file starts being collected, moving live entries into another file and in the end removing the old file from disk."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:54
msgid "Most of the in-memory structures in Soft Index File Store are bounded, therefore you don't have to be afraid of OOMEs. You can also configure the limits for concurrently open files as well (so that you don't run out of file descriptors)."
msgstr ""

#. type: Title ==
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:55
#, no-wrap
msgid "How to configure SIFS"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:58
msgid "The configuration is no different from regular cache store:"
msgstr ""

#. type: Title ==
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:61
#, no-wrap
msgid "Implementation details"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:69
msgid "The Index does not use single file, in fact it can be split into multiple segments. That's because the algorithm updating this B+ tree is designed as single writer - multiple readers, but that could make the writer thread (called 'Index Updater') the bottleneck. Therefore, you can set how many segments should the Index be split into (according to keys' hashCode())."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:76
msgid "Each node in the Index stores 'prefix' of all keys (or rather the serialized forms) used in the node in order to reduce the space required for the node. This comes with the assumption that the prefixes are often similar (e.g. when you use key \"user000001\" and \"user000002\"). If you can change how the keys are serialized, it is encouraged to move the changing part of the key to the end of the serialized data."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:86
msgid "The data are written by single thread as well, the 'Log Appender'.  There's no reason to let threads that access the cache store compete over file-system - Log Appender queues the write results, writes them into the file and wakes up the waiting thread. There are 2 possibly unnecessary context-switches, but in the original design we wanted to allow the write request to return only after the data have been fsynced.  By batching the writes, Log Appender allows this as a configuration option - then you can be sure that the data are already on disk when the call returns."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:91
msgid "When the entry is modified, the Index needs to be updated. The request is sent to Index Updater via bounded queue and the newest entry location is stored in Temporary Table until this is stored in the Index. The updated nodes are eventually offloaded onto disk in this way."
msgstr ""

#. type: Title ==
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:92
#, no-wrap
msgid "Known limitations"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:101
msgid "Size of a node in the Index is limited, by default it is 4096 bytes, though it can be configured. This size also limits the key length (or rather the length of the serialized form): you can't use keys longer than size of the node - 15 bytes. Moreover, the key length is stored as 'short', limiting it to 32767 bytes. There's no way how you can use longer keys - SIFS throws an exception when the key is longer after serialization."
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:106
msgid "When entries are stored with expiration, SIFS does not discover the a file is full of expired entries and the compaction of old data files may not be started ever (method AdvancedStore.purgeExpired() is not implemented). This can lead to excessive file-system space usage."
msgstr ""

#. type: Title ==
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:107
#, no-wrap
msgid "Future work"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:113
msgid "What we need to do know is to benchmark SIFS in many configurations and set the optimal values as defaults. However, we run mostly synthetic benchmarks - and that's where you can help. Let's play with Soft Index File Store a bit and tell us what configuration works best for you!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:117
msgid "For storing large keys, building the B+ tree of hashCodes could perform better that storing the whole keys, though it would need additional handling for collisions. Tell us what keys do you use, please!"
msgstr ""

#. type: Plain text
#: upstream/_posts/2014-10-31-soft-index-file-store.adoc:124
msgid "Currently, each index update needs to be eventually stored, and that means one or more writes into the file-system even when this is not necessary. In the future, we might try to use phantom references instead of soft references to write the Index only when it needs to release some memory. However, this requires a lot of further work, so test SIFS today and let us now how do you like it!"
msgstr ""
